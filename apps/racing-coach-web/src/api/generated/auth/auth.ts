/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * Racing Coach Server
 * API server for racing telemetry data collection and analysis
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  AuthSessionListResponse,
  AuthorizeDeviceRequest,
  ConfirmDeviceAuthorization200,
  DeviceAuthorizationRequest,
  DeviceAuthorizationResponse,
  DeviceAuthorizationStatus,
  DeviceTokenListResponse,
  DeviceTokenRequest,
  DeviceTokenResponse,
  HTTPValidationError,
  LoginRequest,
  LoginResponse,
  Logout200,
  RegisterRequest,
  RegisterResponse,
  RevokeDeviceToken200,
  RevokeSession200,
  UserResponse,
} from ".././models";

import { customInstance } from "../../client";
import type { ErrorType, BodyType } from "../../client";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Register a new user account.
 * @summary Register
 */
export const register = (
  registerRequest: BodyType<RegisterRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<RegisterResponse>(
    {
      url: `/api/v1/auth/register`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: registerRequest,
      signal,
    },
    options,
  );
};

export const getRegisterMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof register>>,
    TError,
    { data: BodyType<RegisterRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof register>>,
  TError,
  { data: BodyType<RegisterRequest> },
  TContext
> => {
  const mutationKey = ["register"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof register>>,
    { data: BodyType<RegisterRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return register(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RegisterMutationResult = NonNullable<
  Awaited<ReturnType<typeof register>>
>;
export type RegisterMutationBody = BodyType<RegisterRequest>;
export type RegisterMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Register
 */
export const useRegister = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof register>>,
      TError,
      { data: BodyType<RegisterRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof register>>,
  TError,
  { data: BodyType<RegisterRequest> },
  TContext
> => {
  const mutationOptions = getRegisterMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Login with email and password.
 * @summary Login
 */
export const login = (
  loginRequest: BodyType<LoginRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<LoginResponse>(
    {
      url: `/api/v1/auth/login`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: loginRequest,
      signal,
    },
    options,
  );
};

export const getLoginMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof login>>,
    TError,
    { data: BodyType<LoginRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof login>>,
  TError,
  { data: BodyType<LoginRequest> },
  TContext
> => {
  const mutationKey = ["login"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof login>>,
    { data: BodyType<LoginRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return login(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type LoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof login>>
>;
export type LoginMutationBody = BodyType<LoginRequest>;
export type LoginMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Login
 */
export const useLogin = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof login>>,
      TError,
      { data: BodyType<LoginRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof login>>,
  TError,
  { data: BodyType<LoginRequest> },
  TContext
> => {
  const mutationOptions = getLoginMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Logout current session.
 * @summary Logout
 */
export const logout = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Logout200>(
    { url: `/api/v1/auth/logout`, method: "POST", signal },
    options,
  );
};

export const getLogoutMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof logout>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof logout>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["logout"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof logout>>,
    void
  > = () => {
    return logout(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type LogoutMutationResult = NonNullable<
  Awaited<ReturnType<typeof logout>>
>;

export type LogoutMutationError = ErrorType<unknown>;

/**
 * @summary Logout
 */
export const useLogout = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof logout>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof logout>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getLogoutMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Get current user profile.
 * @summary Get Me
 */
export const getCurrentUser = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<UserResponse>(
    { url: `/api/v1/auth/me`, method: "GET", signal },
    options,
  );
};

export const getGetCurrentUserQueryKey = () => {
  return [`/api/v1/auth/me`] as const;
};

export const getGetCurrentUserQueryOptions = <
  TData = Awaited<ReturnType<typeof getCurrentUser>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCurrentUserQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentUser>>> = ({
    signal,
  }) => getCurrentUser(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCurrentUser>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCurrentUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCurrentUser>>
>;
export type GetCurrentUserQueryError = ErrorType<unknown>;

export function useGetCurrentUser<
  TData = Awaited<ReturnType<typeof getCurrentUser>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentUser>>,
          TError,
          Awaited<ReturnType<typeof getCurrentUser>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCurrentUser<
  TData = Awaited<ReturnType<typeof getCurrentUser>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentUser>>,
          TError,
          Awaited<ReturnType<typeof getCurrentUser>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCurrentUser<
  TData = Awaited<ReturnType<typeof getCurrentUser>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Me
 */

export function useGetCurrentUser<
  TData = Awaited<ReturnType<typeof getCurrentUser>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetCurrentUserQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * List all active sessions for current user.
 * @summary List Sessions
 */
export const listSessions = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthSessionListResponse>(
    { url: `/api/v1/auth/sessions`, method: "GET", signal },
    options,
  );
};

export const getListSessionsQueryKey = () => {
  return [`/api/v1/auth/sessions`] as const;
};

export const getListSessionsQueryOptions = <
  TData = Awaited<ReturnType<typeof listSessions>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listSessions>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListSessionsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listSessions>>> = ({
    signal,
  }) => listSessions(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listSessions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListSessionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listSessions>>
>;
export type ListSessionsQueryError = ErrorType<unknown>;

export function useListSessions<
  TData = Awaited<ReturnType<typeof listSessions>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSessions>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSessions>>,
          TError,
          Awaited<ReturnType<typeof listSessions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListSessions<
  TData = Awaited<ReturnType<typeof listSessions>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSessions>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSessions>>,
          TError,
          Awaited<ReturnType<typeof listSessions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListSessions<
  TData = Awaited<ReturnType<typeof listSessions>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSessions>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List Sessions
 */

export function useListSessions<
  TData = Awaited<ReturnType<typeof listSessions>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listSessions>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getListSessionsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Revoke a specific session.
 * @summary Revoke Session
 */
export const revokeSession = (
  sessionId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RevokeSession200>(
    { url: `/api/v1/auth/sessions/${sessionId}`, method: "DELETE" },
    options,
  );
};

export const getRevokeSessionMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof revokeSession>>,
    TError,
    { sessionId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof revokeSession>>,
  TError,
  { sessionId: string },
  TContext
> => {
  const mutationKey = ["revokeSession"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof revokeSession>>,
    { sessionId: string }
  > = (props) => {
    const { sessionId } = props ?? {};

    return revokeSession(sessionId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RevokeSessionMutationResult = NonNullable<
  Awaited<ReturnType<typeof revokeSession>>
>;

export type RevokeSessionMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Revoke Session
 */
export const useRevokeSession = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof revokeSession>>,
      TError,
      { sessionId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof revokeSession>>,
  TError,
  { sessionId: string },
  TContext
> => {
  const mutationOptions = getRevokeSessionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * List all device tokens for current user.
 * @summary List Devices
 */
export const listDeviceTokens = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<DeviceTokenListResponse>(
    { url: `/api/v1/auth/devices`, method: "GET", signal },
    options,
  );
};

export const getListDeviceTokensQueryKey = () => {
  return [`/api/v1/auth/devices`] as const;
};

export const getListDeviceTokensQueryOptions = <
  TData = Awaited<ReturnType<typeof listDeviceTokens>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listDeviceTokens>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListDeviceTokensQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listDeviceTokens>>
  > = ({ signal }) => listDeviceTokens(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listDeviceTokens>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListDeviceTokensQueryResult = NonNullable<
  Awaited<ReturnType<typeof listDeviceTokens>>
>;
export type ListDeviceTokensQueryError = ErrorType<unknown>;

export function useListDeviceTokens<
  TData = Awaited<ReturnType<typeof listDeviceTokens>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listDeviceTokens>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listDeviceTokens>>,
          TError,
          Awaited<ReturnType<typeof listDeviceTokens>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListDeviceTokens<
  TData = Awaited<ReturnType<typeof listDeviceTokens>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listDeviceTokens>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listDeviceTokens>>,
          TError,
          Awaited<ReturnType<typeof listDeviceTokens>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useListDeviceTokens<
  TData = Awaited<ReturnType<typeof listDeviceTokens>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listDeviceTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List Devices
 */

export function useListDeviceTokens<
  TData = Awaited<ReturnType<typeof listDeviceTokens>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listDeviceTokens>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getListDeviceTokensQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Revoke a device token.
 * @summary Revoke Device
 */
export const revokeDeviceToken = (
  tokenId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RevokeDeviceToken200>(
    { url: `/api/v1/auth/devices/${tokenId}`, method: "DELETE" },
    options,
  );
};

export const getRevokeDeviceTokenMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof revokeDeviceToken>>,
    TError,
    { tokenId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof revokeDeviceToken>>,
  TError,
  { tokenId: string },
  TContext
> => {
  const mutationKey = ["revokeDeviceToken"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof revokeDeviceToken>>,
    { tokenId: string }
  > = (props) => {
    const { tokenId } = props ?? {};

    return revokeDeviceToken(tokenId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RevokeDeviceTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof revokeDeviceToken>>
>;

export type RevokeDeviceTokenMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Revoke Device
 */
export const useRevokeDeviceToken = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof revokeDeviceToken>>,
      TError,
      { tokenId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof revokeDeviceToken>>,
  TError,
  { tokenId: string },
  TContext
> => {
  const mutationOptions = getRevokeDeviceTokenMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Initiate OAuth device authorization flow.

Called by desktop client to get device_code and user_code.
The user_code should be displayed to the user who then enters it
at the verification_uri in their browser.
 * @summary Initiate Device Authorization
 */
export const initiateDeviceAuthorization = (
  deviceAuthorizationRequest: BodyType<DeviceAuthorizationRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<DeviceAuthorizationResponse>(
    {
      url: `/api/v1/auth/device/authorize`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: deviceAuthorizationRequest,
      signal,
    },
    options,
  );
};

export const getInitiateDeviceAuthorizationMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof initiateDeviceAuthorization>>,
    TError,
    { data: BodyType<DeviceAuthorizationRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof initiateDeviceAuthorization>>,
  TError,
  { data: BodyType<DeviceAuthorizationRequest> },
  TContext
> => {
  const mutationKey = ["initiateDeviceAuthorization"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof initiateDeviceAuthorization>>,
    { data: BodyType<DeviceAuthorizationRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return initiateDeviceAuthorization(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type InitiateDeviceAuthorizationMutationResult = NonNullable<
  Awaited<ReturnType<typeof initiateDeviceAuthorization>>
>;
export type InitiateDeviceAuthorizationMutationBody =
  BodyType<DeviceAuthorizationRequest>;
export type InitiateDeviceAuthorizationMutationError =
  ErrorType<HTTPValidationError>;

/**
 * @summary Initiate Device Authorization
 */
export const useInitiateDeviceAuthorization = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof initiateDeviceAuthorization>>,
      TError,
      { data: BodyType<DeviceAuthorizationRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof initiateDeviceAuthorization>>,
  TError,
  { data: BodyType<DeviceAuthorizationRequest> },
  TContext
> => {
  const mutationOptions =
    getInitiateDeviceAuthorizationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Poll for device token.

Called by desktop client after initiating device authorization.
The client should poll at the interval specified in the authorization response.

Returns the access token if authorized, or an error response if still pending,
denied, or expired.
 * @summary Poll Device Token
 */
export const pollDeviceToken = (
  deviceTokenRequest: BodyType<DeviceTokenRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<DeviceTokenResponse>(
    {
      url: `/api/v1/auth/device/token`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: deviceTokenRequest,
      signal,
    },
    options,
  );
};

export const getPollDeviceTokenMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof pollDeviceToken>>,
    TError,
    { data: BodyType<DeviceTokenRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof pollDeviceToken>>,
  TError,
  { data: BodyType<DeviceTokenRequest> },
  TContext
> => {
  const mutationKey = ["pollDeviceToken"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof pollDeviceToken>>,
    { data: BodyType<DeviceTokenRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return pollDeviceToken(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PollDeviceTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof pollDeviceToken>>
>;
export type PollDeviceTokenMutationBody = BodyType<DeviceTokenRequest>;
export type PollDeviceTokenMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Poll Device Token
 */
export const usePollDeviceToken = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof pollDeviceToken>>,
      TError,
      { data: BodyType<DeviceTokenRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof pollDeviceToken>>,
  TError,
  { data: BodyType<DeviceTokenRequest> },
  TContext
> => {
  const mutationOptions = getPollDeviceTokenMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Authorize a device from web UI.

User enters the user_code shown on their desktop client.
This endpoint requires authentication (user must be logged in via web).
 * @summary Authorize Device From Web
 */
export const confirmDeviceAuthorization = (
  authorizeDeviceRequest: BodyType<AuthorizeDeviceRequest>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ConfirmDeviceAuthorization200>(
    {
      url: `/api/v1/auth/device/confirm`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: authorizeDeviceRequest,
      signal,
    },
    options,
  );
};

export const getConfirmDeviceAuthorizationMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof confirmDeviceAuthorization>>,
    TError,
    { data: BodyType<AuthorizeDeviceRequest> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof confirmDeviceAuthorization>>,
  TError,
  { data: BodyType<AuthorizeDeviceRequest> },
  TContext
> => {
  const mutationKey = ["confirmDeviceAuthorization"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof confirmDeviceAuthorization>>,
    { data: BodyType<AuthorizeDeviceRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return confirmDeviceAuthorization(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ConfirmDeviceAuthorizationMutationResult = NonNullable<
  Awaited<ReturnType<typeof confirmDeviceAuthorization>>
>;
export type ConfirmDeviceAuthorizationMutationBody =
  BodyType<AuthorizeDeviceRequest>;
export type ConfirmDeviceAuthorizationMutationError =
  ErrorType<HTTPValidationError>;

/**
 * @summary Authorize Device From Web
 */
export const useConfirmDeviceAuthorization = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof confirmDeviceAuthorization>>,
      TError,
      { data: BodyType<AuthorizeDeviceRequest> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof confirmDeviceAuthorization>>,
  TError,
  { data: BodyType<AuthorizeDeviceRequest> },
  TContext
> => {
  const mutationOptions = getConfirmDeviceAuthorizationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Get the status of a device authorization.

Used by the web UI to show device details before confirming.
 * @summary Get Device Authorization Status
 */
export const getDeviceAuthorizationStatus = (
  userCode: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<DeviceAuthorizationStatus>(
    { url: `/api/v1/auth/device/status/${userCode}`, method: "GET", signal },
    options,
  );
};

export const getGetDeviceAuthorizationStatusQueryKey = (userCode?: string) => {
  return [`/api/v1/auth/device/status/${userCode}`] as const;
};

export const getGetDeviceAuthorizationStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof getDeviceAuthorizationStatus>>,
  TError = ErrorType<HTTPValidationError>,
>(
  userCode: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeviceAuthorizationStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetDeviceAuthorizationStatusQueryKey(userCode);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDeviceAuthorizationStatus>>
  > = ({ signal }) =>
    getDeviceAuthorizationStatus(userCode, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userCode,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getDeviceAuthorizationStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDeviceAuthorizationStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDeviceAuthorizationStatus>>
>;
export type GetDeviceAuthorizationStatusQueryError =
  ErrorType<HTTPValidationError>;

export function useGetDeviceAuthorizationStatus<
  TData = Awaited<ReturnType<typeof getDeviceAuthorizationStatus>>,
  TError = ErrorType<HTTPValidationError>,
>(
  userCode: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeviceAuthorizationStatus>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDeviceAuthorizationStatus>>,
          TError,
          Awaited<ReturnType<typeof getDeviceAuthorizationStatus>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDeviceAuthorizationStatus<
  TData = Awaited<ReturnType<typeof getDeviceAuthorizationStatus>>,
  TError = ErrorType<HTTPValidationError>,
>(
  userCode: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeviceAuthorizationStatus>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDeviceAuthorizationStatus>>,
          TError,
          Awaited<ReturnType<typeof getDeviceAuthorizationStatus>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDeviceAuthorizationStatus<
  TData = Awaited<ReturnType<typeof getDeviceAuthorizationStatus>>,
  TError = ErrorType<HTTPValidationError>,
>(
  userCode: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeviceAuthorizationStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get Device Authorization Status
 */

export function useGetDeviceAuthorizationStatus<
  TData = Awaited<ReturnType<typeof getDeviceAuthorizationStatus>>,
  TError = ErrorType<HTTPValidationError>,
>(
  userCode: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDeviceAuthorizationStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetDeviceAuthorizationStatusQueryOptions(
    userCode,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}
